<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>神秘圣诞祝福 - Scratch to Reveal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- 基础设置 --- */
        body {
            margin: 0;
            overflow: hidden; /* 防止刮奖时页面滚动 */
            background: radial-gradient(circle at 50% 30%, #1e293b 0%, #020617 100%);
            font-family: 'Noto Serif SC', serif;
            touch-action: none; /* 禁用默认触摸行为 */
        }

        .font-script { font-family: 'Great Vibes', cursive; }

        /* --- 玻璃拟态卡片 --- */
        .glass-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            transform: translateZ(0);
        }

        /* --- 刮刮乐容器 --- */
        .scratch-container {
            position: relative;
            width: 300px;
            height: 420px;
            margin: 0 auto;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 
                0 0 0 1px rgba(255,255,255,0.1),
                0 20px 40px rgba(0,0,0,0.6);
            background: #000;
        }

        .hidden-content {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 60%, #451a03 0%, #020617 90%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            z-index: 1;
            padding-bottom: 30px;
            box-sizing: border-box;
        }

        #scratch-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            cursor: crosshair;
            touch-action: none; /* 关键：防止触摸滚动 */
            transition: opacity 1.5s ease-in-out; 
        }

        .canvas-fade-out {
            opacity: 0 !important;
            pointer-events: none;
        }

        /* --- 混合粒子树 --- */
        .mixed-tree {
            position: absolute;
            top: 40px;
            width: 260px;
            height: 300px; 
            display: flex;
            justify-content: center;
            align-items: flex-end;
            z-index: 0;
        }

        .leaf-particle {
            position: absolute;
            border-radius: 50%;
            background-color: #064e3b;
        }

        .light-particle {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            z-index: 2;
            animation: twinkle var(--duration) ease-in-out infinite alternate;
        }

        /* 新增：礼物盒子样式 */
        .gift-particle {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 1px;
            z-index: 3;
            box-shadow: 1px 2px 4px rgba(0,0,0,0.6);
            /* 十字丝带效果 */
            background-image: 
                linear-gradient(90deg, transparent 40%, rgba(255,255,255,0.7) 40%, rgba(255,255,255,0.7) 60%, transparent 60%),
                linear-gradient(0deg, transparent 40%, rgba(255,255,255,0.7) 40%, rgba(255,255,255,0.7) 60%, transparent 60%);
        }

        /* 树顶星星动画 */
        .tree-star {
            text-shadow: 0 0 15px #fbbf24, 0 0 30px #f59e0b;
            animation: star-pulse 2s infinite alternate;
        }
        @keyframes star-pulse {
            from { transform: translateX(-50%) scale(1); filter: brightness(100%); }
            to { transform: translateX(-50%) scale(1.2); filter: brightness(130%); }
        }

        @keyframes twinkle {
            0% { transform: scale(1); opacity: 0.6; box-shadow: 0 0 2px rgba(251, 191, 36, 0.4); }
            100% { transform: scale(1.3); opacity: 1; box-shadow: 0 0 8px rgba(251, 191, 36, 0.9); }
        }

        @keyframes bounce-gentle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .animate-bounce-gentle { animation: bounce-gentle 2s infinite ease-in-out; }

        #snow-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .scale-in {
            animation: scaleIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            transform: scale(0);
            opacity: 0;
        }
        @keyframes scaleIn { to { transform: scale(1); opacity: 1; } }

        .fade-in-up {
            animation: fadeInUp 0.8s ease forwards;
            opacity: 0;
            transform: translateY(20px);
        }
        @keyframes fadeInUp { to { opacity: 1; transform: translateY(0); } }

    </style>
</head>
<body class="h-screen w-full flex items-center justify-center relative text-slate-100">

    <canvas id="snow-canvas"></canvas>

    <div class="glass-card z-10 p-6 md:p-8 rounded-2xl text-center w-[90%] max-w-[420px] relative transition-all duration-500" id="main-card">
        
        <!-- 阶段 1: 礼物盒 -->
        <div id="scene-gift" class="flex flex-col items-center justify-center py-10">
            <h1 class="text-3xl md:text-4xl text-blue-100 font-script mb-8 tracking-wider drop-shadow-lg opacity-90">Warmth in Winter</h1>
            
            <div class="cursor-pointer group relative p-12 transition-transform duration-300 active:scale-95" onclick="prepareScratchCard()">
                <div class="absolute inset-0 bg-blue-400 blur-[50px] opacity-20 group-hover:opacity-30 transition-opacity rounded-full"></div>
                
                <svg width="140" height="140" viewBox="0 0 100 100" class="relative z-10 animate-bounce-gentle group-hover:scale-105 transition-transform duration-300">
                    <rect x="20" y="35" width="60" height="50" rx="4" fill="#1e3a8a" />
                    <rect x="15" y="20" width="70" height="15" rx="2" fill="#2563eb" />
                    <rect x="45" y="20" width="10" height="65" fill="#fcd34d" />
                    <rect x="15" y="45" width="70" height="10" fill="#fcd34d" />
                    <path d="M50 22 C50 22, 30 5, 20 15 C10 25, 40 30, 50 22" fill="#fbbf24" />
                    <path d="M50 22 C50 22, 70 5, 80 15 C90 25, 60 30, 50 22" fill="#fbbf24" />
                </svg>
            </div>
            
            <p class="mt-4 text-lg text-blue-200/70 tracking-widest animate-pulse font-light">Tap to Defrost</p>
        </div>

        <!-- 阶段 2: 雾气窗户 -->
        <div id="scene-scratch" class="hidden flex-col items-center">
            <h2 class="text-xl text-blue-100/80 font-serif mb-4 tracking-widest uppercase fade-in-up text-xs">Wipe the frost</h2>
            
            <div class="scratch-container scale-in shadow-2xl relative">
                <div class="hidden-content">
                    <div id="tree-container" class="mixed-tree"></div>
                    
                    <div class="text-center z-10 relative drop-shadow-lg bg-black/20 p-4 rounded-xl backdrop-blur-[2px]">
                        <p class="text-amber-300 text-2xl font-bold mb-2 font-script">Merry Christmas</p>
                        <p class="text-orange-50/90 text-sm leading-relaxed font-light">
                            风雪再大<br>
                            也吹不散这份暖意<br>
                            <span class="text-yellow-200 font-medium mt-2 block">平安喜乐 · 万事胜意</span>
                        </p>
                    </div>
                </div>

                <canvas id="scratch-canvas"></canvas>
            </div>

            <button onclick="resetCard()" id="btn-reset" class="mt-6 px-8 py-2 border border-blue-300/30 text-blue-200 rounded-full text-xs tracking-widest transition-all opacity-0 pointer-events-none hover:bg-blue-500/10">
                FREEZE AGAIN
            </button>
        </div>

    </div>

    <div class="absolute bottom-5 text-gray-600 text-[10px] tracking-[0.3em] opacity-40 uppercase">
        Designed for you
    </div>

    <script>
        /* ------------------ 0. 生成混合粒子树 ------------------ */
        function createTree() {
            const treeContainer = document.getElementById('tree-container');
            treeContainer.innerHTML = '';
            const levels = 22; 
            const leafColors = ['#064e3b', '#065f46', '#14532d', '#166534', '#115e59'];

            // 1. 生成树叶层
            for(let i=0; i<levels; i++) {
                // 修改：将宽度系数从 10 增加到 12，让树稍宽一点
                const width = i * 12 + 5;
                const y = i * 13 + 25;
                const leafCount = i * 5 + 10; 
                for(let j=0; j<leafCount; j++) {
                    const leaf = document.createElement('div');
                    leaf.classList.add('leaf-particle');
                    const randomX = (Math.random() - 0.5) + (Math.random() - 0.5); 
                    const offsetX = randomX * width * 0.6; 
                    const offsetY = y + (Math.random() * 12);
                    
                    const size = Math.random() * 5 + 3; 
                    
                    const color = leafColors[Math.floor(Math.random() * leafColors.length)];
                    leaf.style.left = `calc(50% + ${offsetX}px)`;
                    leaf.style.top = `${offsetY}px`;
                    leaf.style.width = `${size}px`;
                    leaf.style.height = `${size}px`;
                    leaf.style.backgroundColor = color;
                    leaf.style.opacity = Math.random() * 0.6 + 0.4; 
                    leaf.style.filter = `blur(${Math.random() * 0.5}px)`; 
                    treeContainer.appendChild(leaf);
                }
            }

            // 2. 生成灯光和礼物
            for(let i=0; i<levels; i++) {
                // 修改：匹配新的树宽 (系数 12)
                const width = i * 12;
                const y = i * 13 + 25;

                // 灯光
                if (i % 2 === 0) {
                    const lightCount = Math.floor(i / 2) + 2;
                    for(let j=0; j<lightCount; j++) {
                        const dot = document.createElement('div');
                        dot.classList.add('light-particle');
                        const offsetX = (Math.random() - 0.5) * width * 0.7;
                        const offsetY = y + (Math.random() * 10);
                        let color = '#fbbf24'; 
                        if(Math.random() > 0.85) color = '#f87171'; 
                        const size = Math.random() * 3 + 2;
                        const duration = Math.random() * 2 + 1.5;
                        dot.style.left = `calc(50% + ${offsetX}px)`;
                        dot.style.top = `${offsetY}px`;
                        dot.style.width = `${size}px`;
                        dot.style.height = `${size}px`;
                        dot.style.backgroundColor = color;
                        dot.style.boxShadow = `0 0 ${size}px ${color}`;
                        dot.style.setProperty('--duration', `${duration}s`);
                        treeContainer.appendChild(dot);
                    }
                }

                // 礼物盒 - 随机放置
                if (i > 6 && Math.random() > 0.6) {
                    const gift = document.createElement('div');
                    gift.classList.add('gift-particle');
                    const offsetX = (Math.random() - 0.5) * width * 0.7;
                    const offsetY = y + (Math.random() * 10);
                    
                    const colors = ['#ef4444', '#3b82f6', '#8b5cf6', '#f59e0b'];
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    gift.style.left = `calc(50% + ${offsetX}px)`;
                    gift.style.top = `${offsetY}px`;
                    gift.style.backgroundColor = color;
                    gift.style.transform = `rotate(${Math.random()*20 - 10}deg)`; 
                    
                    treeContainer.appendChild(gift);
                }
            }
            
            // 3. 树顶星星
            const star = document.createElement('div');
            star.innerHTML = '★'; 
            star.className = 'absolute top-[5px] left-1/2 text-yellow-300 text-4xl z-10 tree-star';
            treeContainer.appendChild(star);
        }

        /* ------------------ 1. 雾气玻璃逻辑 (修复坐标) ------------------ */
        const canvas = document.getElementById('scratch-canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        let isDrawing = false;
        let isRevealed = false;
        let width, height;

        function initScratchCanvas() {
            const container = document.querySelector('.scratch-container');
            width = container.offsetWidth || 300;
            height = container.offsetHeight || 420;
            canvas.width = width;
            canvas.height = height;

            drawFrostTexture();
            ctx.globalCompositeOperation = 'destination-out';
        }

        function drawFrostTexture() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(220, 230, 240, 0.95)'; // 略微增加不透明度
            ctx.fillRect(0, 0, width, height);

            for(let i=0; i<1000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.3)' : 'rgba(200,220,255,0.3)';
                const x = Math.random() * width;
                const y = Math.random() * height;
                const r = Math.random() * 2;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI*2);
                ctx.fill();
            }

            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
            ctx.lineWidth = 1;
            for(let i=0; i<50; i++) {
                ctx.beginPath();
                const x = Math.random() * width;
                const y = Math.random() * height;
                ctx.moveTo(x, y);
                ctx.lineTo(x + (Math.random()-0.5)*40, y + (Math.random()-0.5)*40);
                ctx.stroke();
            }
        }

        // 关键修复：处理 CSS 缩放导致的坐标偏移
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            // 计算缩放比例
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function scratch(e) {
            if (!isDrawing || isRevealed) return;
            e.preventDefault();

            const pos = getPos(e);
            
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 45, 0, Math.PI * 2); 
            ctx.shadowBlur = 40; 
            ctx.shadowColor = 'rgba(0,0,0,1)'; 
            ctx.fill();
            ctx.shadowBlur = 0;

            if (Math.random() > 0.7) checkPercentage(); // 提高检查频率
        }

        function checkPercentage() {
            const imageData = ctx.getImageData(0, 0, width, height);
            const pixels = imageData.data;
            let clearedCount = 0;
            const step = 20; 

            for (let i = 3; i < pixels.length; i += 4 * step) {
                if (pixels[i] < 50) clearedCount++;
            }

            const totalPixels = (width * height) / step;
            if ((clearedCount / totalPixels) * 100 > 40) autoReveal();
        }

        function autoReveal() {
            if (isRevealed) return;
            isRevealed = true;
            canvas.classList.add('canvas-fade-out'); 
            document.getElementById('btn-reset').classList.remove('opacity-0', 'pointer-events-none');
            createConfetti();
        }

        // 绑定事件
        ['mousedown', 'touchstart'].forEach(e => 
            canvas.addEventListener(e, (ev) => { isDrawing = true; scratch(ev); }));
        
        ['mousemove', 'touchmove'].forEach(e => 
            canvas.addEventListener(e, scratch));
        
        ['mouseup', 'mouseleave', 'touchend'].forEach(e => 
            canvas.addEventListener(e, () => isDrawing = false));

        /* ------------------ 2. 场景切换 ------------------ */
        const sceneGift = document.getElementById('scene-gift');
        const sceneScratch = document.getElementById('scene-scratch');

        function prepareScratchCard() {
            createTree();
            sceneScratch.classList.remove('hidden');
            sceneScratch.style.opacity = '0';
            
            setTimeout(() => {
                initScratchCanvas();
                sceneGift.style.transition = 'opacity 0.5s, transform 0.5s';
                sceneGift.style.opacity = '0';
                sceneGift.style.transform = 'scale(0.8)';

                setTimeout(() => {
                    sceneGift.classList.add('hidden');
                    sceneScratch.style.display = 'flex';
                    requestAnimationFrame(() => {
                        sceneScratch.style.transition = 'opacity 1s';
                        sceneScratch.style.opacity = '1';
                    });
                }, 500);
            }, 50);
        }

        function resetCard() {
            sceneScratch.style.opacity = '0';
            setTimeout(() => {
                sceneScratch.classList.add('hidden');
                sceneGift.classList.remove('hidden');
                sceneGift.style.opacity = '1';
                sceneGift.style.transform = 'scale(1)';
                canvas.classList.remove('canvas-fade-out');
                isRevealed = false;
                document.getElementById('btn-reset').classList.add('opacity-0', 'pointer-events-none');
            }, 800);
        }

        /* ------------------ 3. 背景动效 ------------------ */
        const snowCanvas = document.getElementById('snow-canvas');
        const sCtx = snowCanvas.getContext('2d');
        let sw, sh;
        const flakes = [];

        function resizeSnow() {
            sw = window.innerWidth;
            sh = window.innerHeight;
            snowCanvas.width = sw;
            snowCanvas.height = sh;
        }
        window.addEventListener('resize', resizeSnow);
        resizeSnow();

        for(let i=0; i<80; i++) {
            flakes.push({
                x: Math.random() * sw,
                y: Math.random() * sh,
                r: Math.random() * 2 + 1,
                d: Math.random() * 1 + 0.5
            });
        }

        function drawSnow() {
            sCtx.clearRect(0, 0, sw, sh);
            sCtx.fillStyle = 'rgba(255, 255, 255, 0.4)'; 
            sCtx.beginPath();
            flakes.forEach(f => {
                sCtx.moveTo(f.x, f.y);
                sCtx.arc(f.x, f.y, f.r, 0, Math.PI*2);
                f.y += f.d;
                f.x += Math.sin(f.y * 0.05) * 0.5;
                if(f.y > sh) { f.y = 0; f.x = Math.random() * sw; }
            });
            sCtx.fill();
            requestAnimationFrame(drawSnow);
        }
        drawSnow();

        function createConfetti() {
            const colors = ['#fde047', '#fff', '#60a5fa']; 
            const container = document.querySelector('.scratch-container');
            const rect = container.getBoundingClientRect();
            const cx = rect.left + rect.width/2;
            const cy = rect.top + rect.height/2;

            for(let i=0; i<50; i++) {
                const el = document.createElement('div');
                el.style.position = 'fixed';
                el.style.left = cx + 'px';
                el.style.top = cy + 'px';
                el.style.width = '5px';
                el.style.height = '5px';
                el.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
                el.style.borderRadius = '50%';
                el.style.pointerEvents = 'none';
                el.style.zIndex = '100';
                document.body.appendChild(el);
                const angle = Math.random() * Math.PI * 2;
                const dist = 60 + Math.random() * 100;
                el.animate([
                    { transform: 'translate(0,0) scale(1)', opacity: 1 },
                    { transform: `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px) scale(0)`, opacity: 0 }
                ], {
                    duration: 1000 + Math.random() * 500,
                    easing: 'ease-out'
                }).onfinish = () => el.remove();
            }
        }
    </script>
</body>
</html>
